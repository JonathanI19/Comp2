/* PROJECT 3 - proj_3.cpp

    @author Jonathan Isely
    @contact jmisely19@gmail.com
    @date 10/29/2023

    Implements a system that models reading data asynchronously from the cloud,
    storing it temporarily in a buffer, and then placing it into a hash table.
 
    Compile:
        make all
    Compile for debug:
        make debug
    Run:
        ./proj_3 [OPT]
        where [OPT] is 1, 2, or 3 depending on which test case you are running.
*/

#include<iostream>
#include<thread>
#include<fstream>
#include<vector>
#include<deque>
#include<chrono>
#include<mutex>
#include "math.h"
using namespace std;
using namespace std::chrono;


/// @brief Student Struct
struct student{

    string first_name, last_name, major;
    float gpa;
    int ID;
    student(string f = "", string l = "", float g = 0.0, int num = 0, string m = "")
    {
        first_name = f;
        last_name = l;
        gpa = g;
        ID = num;
        major = m;
    }
};

/// @brief Class to store hashtable information
class hashTable{
    private:
    int num_elements;

    // 51971 is a prime number that we can use as a length for our hash_function. This is a temporary band-aid.
    // Ideally, each member in the hash table would be a linked list node so we can start
    // off much smaller and dynamically handle collisions. However, for the sake of brevity
    // I will have to hold off on implementing that.
    const static int buff_len = 51971;
    student buffer[buff_len];

    /// @brief Private: Generates hash key based off of multiplication method of hashing
    /// @param id (int) ID from relevant student object
    /// @return (int) Computed Hash Key
    int hash_function(int id){

        u_int64_t val = 0;
        u_int64_t idx = id;

        val = id*id*id;
        for (int i = 0; i < 9; i++){
            idx = idx * (idx%10);
        }
        // guarantee that idx is between 0 and buff_len-1
        val = idx % buff_len;
        // return index derived from id number
        return val;  
    }

    /// @brief Private: Called by insert to verify no collisions are occurring
    /// @param s (student*) Pointer to student object
    /// @param key (int) Key generated by hash function
    void collision_handler(student s, int key){
        int start = key;

        // If current buffer index is empty, insert student
        if (buffer[key].ID == 0){
            buffer[key] = s;
            return;
        }

        // Else: Increment through hashtable until it loops back around to the start
        else {
            while(buffer[key].ID != 0){
                key = (key + 1) % buff_len;
                if (start == key) {
                    cout << "Hash table full" << endl;
                    return;
                }
            }

            // Insert in empty slot
            buffer[key] = s;
        }
    }

    /// @brief Private: Displays student information
    /// @param s (student) Student object
    void display(student s) {
        if (s.ID == 0) {
            cout << "Student: "<< s.ID << " not found." << endl;
        }
        else {
            cout << "(" << s.ID << ") " << s.first_name << " " << s.last_name << ": " << s.gpa << " " << s.major << endl;
        }
    }
    
    public:

    /// @brief Constructor
    hashTable(){
        num_elements = 0;
    }

    /// @brief Method to insert student pointer into hash table
    /// @param s (student*) Pointer to student object
    void insert(student s){
        // Error handling for if hash table is full
        if (num_elements == buff_len) {
            cout << "Hash Table Full" << endl;
            return;
        }

        // Generate hash key
        int key = hash_function(s.ID);

        // Insert w/Collision handling
        collision_handler(s, key);
        num_elements++;
    }

    /// @brief Search through hashtable for specific student
    /// @param ID (int) Student ID to be looked up
    /// @return (student) Student information
    student search(int ID) {
        student temp;
        
        // Get hash key
        int key = hash_function(ID);

        int start = key;

        // Run until break condition
        while(true){

            // If ID matches, break out of loop
            if (buffer[key].ID == ID){
                temp = buffer[key];
                break;
            }

            // If IDs don't match but is still populated, increment key
            else if (buffer[key].ID != ID && buffer[key].ID != 0) {
                key = (key + 1) % buff_len;
            }
            
            // If it loops back around to start position without finding ID, break
            else if (key == start) {
                break;
            }
            
            // break otherwise
            else {
                break;
            }
        }

        // Call display
        display(temp);
        return temp;
    }
};

/// @brief Class used to store incoming data in queue to be popped off as needed
class queue{

    private:
    // Variable declarations
    deque<student> student_queue;
    int num_elements;
    bool isEmpty;

    public:
    /// @brief Constructor
    queue(){
        num_elements = 0;
    }

    /// @brief Insert pointer to student object into queue
    /// @param t (student*) Pointer to student object
    void insert(student t){
        student_queue.push_back(t);
        num_elements++;
    }

    /// @brief Pop student pointer off front of queue
    /// @return (student*) Pointer to student object
    student pop(){

        // Store student data from front and pop off of queue    
        student temp = student_queue.front();
        student_queue.pop_front();

        num_elements--;
        return temp;
    }

    /// @brief Checks to see if queue is empty
    /// @return (bool) True if empty; False if populated with data
    bool is_empty(){
        return (num_elements==0);
    }

};

// You will need these global variables
queue waiting_list;
hashTable student_db;
mutex queue_mutex;

// this controls the input timing. do not edit
bool stop_thread = false;
steady_clock::time_point t1 = steady_clock::now();
float t_elapsed(){
    return duration_cast<seconds>(steady_clock::now() - t1).count();
}

/// @brief Processes input data and inserts from queue to hash table
void process_input_data(){
    student p_student;
    while (!stop_thread){
        queue_mutex.lock();

        // If queue is not empty, pop student off of queue and insert into hash table
        if(waiting_list.is_empty() == false){
            p_student = waiting_list.pop();
            student_db.insert(p_student);
        }

        queue_mutex.unlock();
    }
}

/// @brief Loads data from file
/// @param filename (string) filename to be loaded
void load_data(string filename){

    string shared_path = "/data/courses/ece_3822/current/project_3/";
    string filename_complete = shared_path + filename;

    // create local variables to stash the data for each person as it's
    // read from the file
    float arrival_time,gpa;
    string first,last,major;
    int id;

    ifstream f_id;
    f_id.open(filename_complete,ios_base::in);

    // start the thread that will wait for input data to arrive
    thread thr(process_input_data);

    clock_t t_start = clock();

    while (f_id >> arrival_time){
        // read data for the next person in the file
        f_id >> first;
        f_id >> last;
        f_id >> gpa;
        f_id >> id;
        f_id >> major;

        // wait until their data packet has 'arrived'
        while ( t_elapsed() < arrival_time){
            ;
        }

        // Create new student object from struct
        student temp_student;
        temp_student.first_name = first;
        temp_student.last_name = last;
        temp_student.gpa = gpa;
        temp_student.ID = id;
        temp_student.major = major;
    
        queue_mutex.lock();

        // Insert student object into queue
        waiting_list.insert(temp_student);

        queue_mutex.unlock();

    }

    f_id.close();                       // close the data file
    
    while (!waiting_list.is_empty()){   // wait for the waiting_list queue
        ;                               // to empty out before stopping the 
    }                                   // process_input_data thread
    stop_thread = true;                 // send a signal to the thread to stop running
    thr.join();                         // wait for the thread to finish up
}

int main(int argc, char** argv){
    string filename;

    if (argc !=2 ){
        cout << "ERROR: include a command line arguement of 0, 1, or 2" << endl;
        return -1;
    }

    switch (stoi(argv[1])){
        case 0: filename = "student_data_short.txt"; break;
        case 1: filename = "student_data_medium.txt"; break;
        case 2: filename = "student_data.txt"; break;
    }
    load_data(filename);

    // Testing lookup
    student_db.search(427980112);
    student_db.search(258399712);
    student_db.search(948140115);
    student_db.search(664629914);
    student_db.search(852580016);
    student_db.search(124599717);

    return 0;
}